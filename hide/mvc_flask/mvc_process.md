# 

> 1 使用一个py.class 产生：
    1.1 py 模型
    1.2 js 模型
        1.2.1 view
        1.2.2 module
        1.2.3 control
            这个控制不表达如何控制, 只把用户的控制信息传递给后端

> py.class:
    > m 数据, 类的定义
        m.class.
            实例的初始化(每个对象都是一个类/数组类)
            同结构不同位置的对象, 应该有不同的类名字, 继承自同一个类
        m.init
            init obj
    > v 与数据的初始化有关
        1 最好嵌套
        2   
        3 
    > c 控制
        1 每个对象都有一个独立的名字            +++++++
            所有对象通用类, 初始化自动产生 id
        2 当对象被点击/按下回车之后, 把事件发送给后端
            id + 参数
    
> 怎么产生view 函数?

> 先产生模型
    >> 产生成功
> 拆解 view
    >> 现在去掉一切的封装, 我们直接在
        def v() 里面手写所有的 return (dom)

> 关联 event
    > 把每个可点击、输入 的组件，都必须独立封装，有编号
        > 这需要我们不满足于 def v() 里面的手写内容, 而是需要让组件化的(dom)加入到v里面
        > (dom).id 要进行注册
        > (dom).id 

> compo
    > 所有的compo 都是可以关联event的
    > 如果没有event, 没有必要作为compo
    > 带参数 compo 需要把参数传递给后端, 我们暂时只支持，把compo内部的数据传递出去
    >       那么如何传递compo内部的参数, 就是我们需要的重点

    > compo:
        1 数据 字面传入()
        2 id 自动分配
        3 挂载的行为: 需要在v 里面绑定
        compo.button(
            #id=auto,
            data='self.functor_list',
            event=dict(
                OnClick=root.plan.add_functor(ReadMysql())
            )
        )
            1 这里 onClick 就是 onClick={self.call(self.idx, 'onClick')}
            2 这里的 root.xxx 是执行函数, 用来注册到事件里面
                所有事件应该和module关联

# summery
> 多任务程序 ++++
    我们考虑用户打开多个 plan
    我们必须让所有的节点都能够访问，当前plan(module.root)

    plan = get(plan_name, default_plan_maker())
    set(plan_name, plan)

> id_maker:
    用来给所有的 compo + 类, 注册key
    属于某个plan
    > 每个module = root{
        id_map, 
        data = plan
    }
> event
    1 对于前端发送的回调:
        1 obj.idx > 找到后端 obj
        2 method = method_name
        3 params = dict()
    2 如果注册的回调, 被修改了怎么办？
        (仍然用 idx:)
        约定一个修改规则:
        1 回调访问 确定的对象
            不会被修改
        2 回调访问 不确定的对象(可有可无)
            回调访问子对象
        3 回调修改 而非访问不确定对象
            回调访问确定对象, 由该对象提供标准方法
        4 其他特殊要求，先不实现

> compo:
    用来封装 event+view 的库
    这个产生和编译, compo.js


# 上班时间做什么
因为效率低下，有创造力的工作不在此时做，


> 用新框架实现一个基本页面:
    1 name/f_list/new_f_list/op
        >> 今天搞定/上午搞定

    2 new delete functors
    3 save/load
>
上午已经做通 整个流程
    >> 需要把 key-id 加上
    . 今天
-----------------------------------------------------
我们需要一个 compo 但是compo到底是什么:
1 问题:
    类方法:
        m, v
        我们根据类方法, 产生 m, v
    对象方法:
        产生 idx, clsName
    
    1 我们根据类的声明, 产生 js
    2 v 怎么和compo 关联
        根据 m 的初始化类型, 产生 v
    3 因此, m, v 都是静态变量
        >> 去修改成静态变量

> 增加了compo
    compo 是一个终结符
        任何类调用compo, 而compo, 调用 js.compo 封装的类
        这样我们整个语言就构建出来了
        1 我们的每个类, 都是一个上下文无关语言语法, 描述一个区域里面有多少个子区域
        2 compo类 是一个终结符语法，用来描述某个符号 和真实世界(js/html)的一一对应关系
# xx
..
# xx

# 进度说明
非常牛逼的实现了
a 符号能力
    1 抽象结构是非终结符
        m() 产生通用v
    2 compo(html++)是终结符
        1 compo 定制v
        2 compo 调用的 function, 手动实现

b view 自动产生

# >> 接下来的计划
c compo 下的 event
    js:
        发送信号 => 自动发送信号
        > 传递 call
        > 已经传到后端, 运行良好
    py:
        绑定信号
            <!-- >> 不可验证, 因为数据不能存取 -->
            >> 验证, 当前机制有效
    Auto_type:
        自动类型分析, 用来自动分析 list里存储的 可变类型
        >> 成功
    
## >> 如何存取数据？
save/load
    <!-- 现在的问题是, 数据是每次初始化, 就不可能存储数据 -->
    艰难的完成

# 周二
## 现在需要构建, 数据库, 数据模型
    1 安装mysql, 增加 db_aliyun
        完成
    2 休息一会，然后移植代码
        已经移植了, 现在的问题是:
            怎么开始构建
    >> 已经把之前的算子, 增加到了functor_list 列
    >> 增加了 文本 compo
        >> 这个compo的显示风格不合理, 需要把字符修改一下

这回我们感觉很爽！
现在修改html页面的效率, 已经是以前的n倍了
最快今天到明天可以构建完整的之前的所有设计
----------------------------------------------
> 正在进入mysql-表数据结构的开发
> 已经把 ReadMysql/ColAppend 增加
    >>>>>>>>>
    >> 需要增加一个功能: prev_fields  +++++
        >> functor 调用父节点的方法(传入自己的index)>>
            >> 父节点依次遍历子节点， 调用子节点的 方法: next_fields
                找到index节点, 得到 prev_fields
> save_excel ++++++
    >> 完成
> <input> 改进
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    > placeholder > value
    >>>>>>


.
------------------------------

> 把 code_maker 加入
    >> a 需要把 code_maker 的 参数规范化
        >> 先尝试做通
            >> code generate 和展示 +++
            >> 把code 需要的算子param抽离出来？
                层次化, 组件化完成 ++++++++++++++++
>> 期望今天能够完成所有的！！

    >> b 适当考虑, 算子和 code_maker 一体化
        >> 一定程度 把算子和 plan的其他操作解耦, 把算子独立出来
        > 直接把代码拆开就行, 依赖不深
    
    >> 
.
----------------------------------------------------
# 周三
我们请假一天
把组件搞定, >产生code, 推到git(执行一行命令)

# 周四
在本地同步环境
登陆服务器
调试我们的代码
补充一些简单的内容
>> 我们先不考虑本地同步环境
>> 开始着手写第一个 1v1 表的保存.
    绕过 colAppend
>> 正在准备产生 code
>> 产生成功++++

# 周五我们完成阶段报告
1 明天最重要的事情就是搞定网页版登陆 +++++
然后我们就可以开始调试
    信息加密/解密

这样, 我们把一个搜索功能放在服务器上。
> 搜索功能基本开发完成      +++++++++++++++++++++


>> 完成一个简单例子 1v1
    >>> 一个没有 colAppend 的例子
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        >> 1 通过 db + 关键词, 找到表清单, 然后拿到一个 表结构 +++++++++
        >> 2 要可以新增一个表结构 
            >>(这个以后再自动化)
        >> 3 创建一个真实的自动项目
            现在我们完成了一个 poc 
            还有一个bug, 留在之后解决

>> 一会我们的目标是自动化, 把整个流程做通
    >> 自动化:
        1 现在可以自动把代码推到git上
        2 执行:
            1 在本地转移一下代码: 多行命令
            2 在网页版终端执行
            看到结果, 产生最终文件

2 写文档


# 工作进度和主要工作内容

距离上一轮开发接近一个月, 基本完成了上一轮的预期目标
(大约还有一天的工作量)

本轮开发进行了一次彻底重构, 用时大约两周
因此任务延期

这次重构对于这个项目意义重大
彻底的加速了整个工程的开发进度


# 整个工程的实现结构
整个工程目前大致分为三大部分, web前端, web后段, 编译模块:
模块之间的关系和主要功能是:

1 交互界面
    用来获取生成代码所需要的全部信息, 相当于产生抽象语法树的编译器前端
    1.1 web前端
        1.1.1 基本框架
        1.1.2 数据模型, 和web后端同步
        1.1.3 模型显示
        1.1.4 事件
    1.2 web后端
        1.2.1 flask框架/基本框架
        1.2.2 数据模型, 和web前端同步
        1.2.3 前端事件回调处理模块
2 编译模块
    用来把数据模型转化成代码


# 重构的重要性

目前工程最大的工作量, 来自修改算子
算子是对我们产生的代码, 需要做哪几种行为的原子化抽象
比如我们这次实现的算子是:
1 读mysql, 产生一个数据表(在内存中流式存储)
    (我们查询mysql的时候需要分页查询)
2 关联其他mysql, 给数据表补充一些字段
3 把流式表合并, 存储到 excel文件中

对于我们这个工程来说, 增加或者修改一个算子需要的开发内容是:
1 web前端考虑如何展示这个算子
    并且设计交互过程让用户完成这个算子的定义
    目前主要是以表单的形式表示
2 web后端需要让用户交互相关的各种操作生效
    并对数据模型做更新, 发送给前端
3 算子的代码化
    算子在翻译成代码之前, 需要接收它需要的参数
    不同的算子需要收集不同的参数
    这些参数需要清晰的定义
    参数的定义也许会发生修改

我在开发过程中遇到的主要困难就是, 每当修改算子, 我需要同时修改三个模块
链条过长, 导致频繁修改耗时太多
对算子的灵活修改能力, 最后会成为这个项目用户体验的关键
也是项目成败的胜负手

# 重构策略:
核心是把python翻译成javascript
这样前后端数据定义从两层压缩成一层
(大部分开发过程不再需要考虑和调试前端代码)

实现的细节:
1 数据模型
我们在前端和后端之上, 做了一个抽象
使用唯一的数据模型(python)
然后通过一个编译程序
把这个python数据结构编译成 javascript
而后端仍然可以直接使用这个python模型

2 mvc架构
mvc架构的三个部分
现在全在后端定义
这样的好处是, 显示逻辑不必在前端用javascript实现
统一由后端设计

3 数据模型中的两种类
整个模型相当于一个 上下文无关文法的语法定义:
1 非终结符 是抽象的类
    每个非终结抽象类, 用来对应前端界面中的区域, 或者说显示容器
2 终结符 是标准组件
    这些标准组件在后端定义, 同时被直接翻译成前端的基本组件
    我们不直接使用html页面元素, 这些基本组件是原子化最小单位
    标准组件定义了 前端显示/事件 的标准形式

# 下一阶段的计划
整个工程已经进入[自测和内测]阶段

希望:
每周接受两个poc任务, 从简单到困难, poc任务数量逐渐增加
最好是我在周一拿到需求， 在周四/周五交付

这个阶段的主要工作内容是:
1 增加算子, 使整个框架能够解决更多类型的poc任务
2 改进自动化程度, 以及交互页面的用户体验
3 页面美化
等等





3 总结整个项目(下周, 先把文档完成)
>
1 web前端
    1 模板
    /home/ubuntu/git/npm_pro/pages/mvc_plan/[...plan].js
    2 容器类型parser
    Auto_type
    3 基本组件
    Com_
    4 定义类
        4.1 成员:
            4.1.1 自主成员
            4.1.2 默认成员
                this.idx = data.idx # 定位
                this.cls_type_ = data.cls_type_ # Auto_type
                this.call = data.call # 调用/传递
        4.2 view
            设置传递参数(.call)
            返回 标准dict容器
2 web后端
    1 https服务层:
        app + lib_flask
        按照任务(plan)分块:
            get: 发送数据给前端
            post: 调用事件: module.call
    2 模型曾:
        模型:
            module_base
            mvc_plan
            mvc_functor
            存储,持久化:
                plan_history/
                DB:mysql
                mysql查询工具:
                    mysql_lib/
        组件:
            compo
3 编译
    code_maker/
        code_gen
        panda_functor
    js_maker
.
-------------------------------------------------------------
1 总结整个项目(下周, 先把文档完成)
大致写了个脉络

> 正在改进 select的用户体验
我们应该把不同列, 当作一个对象封装

抽象出 table_line
> 这个重构有价值
    >> table -> {类line, ...} >>>>>>>>>>>>>>>>>>>>>>>
    >> XXXXXXX 没有重构

2 colAppend
    > 1 代码重写, 澄清参数
    > 2 增加颜色标记:
        有bug, 正在 debug
    > 3 产生代码
---------------------------------------------------------------
我们几乎只剩下代码调试了
如果我们这次接受的任务, 比较容易
那么, 不需要增加算子就可以解决问题
---------------------------------------------------------------
考虑用这个优化我们的加载速度
变swr 为 ssr
https://zhuanlan.zhihu.com/p/342759604






