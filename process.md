
# web服务
0 全局搜索
1 一个字段 > 获取 key序列 [db].[tb].[key]
2 选择多个字段, 获取字段集select  [col1,col2,col3..]

# 代码- 特殊类
3 default 对象, raw 对象:
    default对象, 自动过滤 dataStatus
    raw对象, 全 column
4 auto_cond 对象, dataStatus!=3

# 代码- 模型
集成MySQL查询, 能够使用 代码-框架


# 代码- 框架
df1 = A(chunk=1000, chunk_limit=1).join(B
    ).reknow(B2, chunk=1000).join(C
    ).reknow(B3, chunk=1000).join(D
    ).reknow(D2, chunk=1000).find(
        E(chunk=1000).find('sptid', spt_list).list('companys')
    ).groupby(col, max/min/avg
    ).explode(lambda row:new_row
    ).setcol('col', lambda row:F.find('sptid', [row['1'],row['2']]).list['companys'])
    ).rename(col_dict
    ).df
    # 在所有过程执行的时候, 先进行一轮字段检查, reknow 要检查字段是否存在

Excel(name).save({
    name1:df1,
    name2:df2
})

# 任务命名
收到任务:
    1 回复任务命名:
    按照时间戳 + 客户 + 版本

    输出 task_时间戳.xlsx


### 进度:

今天:
0 搞定python环境
    非常 clear. 整合进我们的demo系统中
1 制作mysql模型
    >>    
2 完成web框架
3 完成符合框架代码的业务代码

调整:
今天:
完成快速开发---
实现代码版本的快速开发 , 不在web上实现
-----------------------------------------
非常美, 非常牛叉！
我需要休息一会

# 1 搜索
0 全局搜索  >> 单文件搜索
1 一个字段 > 获取 key序列 [db].[tb].[key]     >> path
2 选择多个字段, 获取字段集select  [col1,col2,col3..]    >> _cols
3 快速搜索字段, _scan

# 2 计算和表示  >>>> 这个等等
3 default 对象, raw 对象:
    default对象, 自动过滤 dataStatus
    raw对象, 全 column
4 auto_cond 对象, dataStatus!=3

# 3 框架实现, 引擎隔离    >> 
1 把 ReadSample 实现为 返回 [_sample,]
    把这个东西命名为Engine
    <!-- ReadMysql -->
2 我们解析所有的配置
    得到一个表, 通过我们的标准框架, 生成配置, 调用引擎
    引擎的使用功能, 要求和 ReadMysql 一致
3 支持流, 块, join, find
    ...

# 4 使用框架完成业务
    ...



周一:
1 实现代码框架

https://github.com/ChrisChenD/module_creator

最好能有一个 ftp 服务, 同步数据
----------------------------------------
>>
1 环境搭建
2 验证需求
---------------------------------------------------------
基本要实现了新页面, 我们现在实现一个页面需要1小时

1 实现了注册资源, 增减资源的方法
>> 需要重新约定注册资源--和表之间的联系，以及如何显示一个 ReadMysql 结构
    >> 晚上搞
>> 如何给一个 ReadMysql机构增加一个通用方法:
    比如 表.通过(list)查询(key_field)添加[append_list]
    a 方法名称
    b 参数:  (prepare args), (key=key_field, full_data=True) [append_list]
.
-----------------------------------
>> 现在正在完善 append 算子
>> 需要增加一个 prev_fields 列
    > 已经增加到后端
    > 需要增加到前端---并且可显示 >>>
    
>> 经过这两天缓慢的开发
第一天增加了一点功能
第二天大重构
>>
我们推进非常吃力
>>
现在终于可以把 prev_list 加入到我们的append中
>> 下一步需要把 button的效果加入
>>>> ??????????????????????????????????????????<<here>>
进展缓慢！！
但是这个速度应当是合理的.
----------------------------------------
tips:
我们可以考虑把列的表示变成 竖排版+折叠(可以收起)



.
---------------------------------------------------------
今天上午的重构:
把prev_list 这部分的代码整合到 现有的系统中
-----------------------------------------------------------------
在陷入新体系更新旧体系的战斗中
我们进展缓慢
---------------------------------------------------------------
其实整体架构有必要尽快重整
> 渐近调整:
1 先让前后两个框架能够对应


    # # >> 我们正在建立一个基本模型
    # 1 直接使用python 
    # 2 模型将统一双方的数据结构:
    #     1. 直接修改python数据结构本身
    #     2. 匹配自动产生相关的javascript数据结构

    #     .. 这样我们透明传递了所有的数据，那么数据的修改只需要我们一次修正
    #     类变成这样一种东西:
    #     1 前端类-后端类
    #     2 前端.view 前端.event(实际上是直接调用后端的module的方法)
    #     3 后端.module
        4 后端 m,c 一体
前端类/后端类 的统一
(还需要自动化： 直接产生代码)

> 完成了一个路由调用的机制
我们现在拥有两个能力:
1 后端的结构可以复制为前端
    >> 还需要增加把后端方法(路由方法), 对应到前端
    这样我们在一个结构化的后端模型中， 对任何一层的调用
        > 都是通过增加后端方法 ， 就可以增加前端回调事件方法
## ---------------------------------------------------------------

今天真的没有时间了:
1 但是今天我们建立了一个远程环境:
以后我们周六周日, 都可以开始工作
以及早晨
---------------------------------------------------------------------
现在的任务:
1 期望能够把 className 编译到前端去
    临时编译一个js
2 期望能够把按钮的事件， 从后端编译到前端。

先做第二个:
----------------------------------
> 把tailwind 搞定, 优化了一下之前的文档

>> 增加数据库和数据
为了防止中毒, 今天就先不搞了
明天再说, 先玩一会, 然后关机出门散步

今天接近完整的把所有的环境构建在了云上
这样就可以尝试其他的方案:
比如周日去公园编程

> 1启动
> 怎么把函数调用传入？
.
a.b([param.b]).c([param.c]).d([param.d])
###
我们把整个框架描述一下, 考虑一下架构有什么问题

1 next.js
    1 生成的数据结构 js.plan.Module
    2 手动修改的 view
    3 前端组件 js.compo
    > 手写/自动分离

2 flask
    1 手写的数据结构 py.plan
    2 后端的组件创造器 py.compo

    3 编译工具, py.plan.Module > js.plan.Module
        1 数据结构
        2 函数(应该删除)
        3 调用命令(这里应该是从plan.root到 node > call([param],...))
> 


后面需要新加入的功能
1 管线设计/控制流设计
    等于 mysql
2 


做视频和画图


