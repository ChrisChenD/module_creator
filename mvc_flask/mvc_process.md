# 

> 1 使用一个py.class 产生：
    1.1 py 模型
    1.2 js 模型
        1.2.1 view
        1.2.2 module
        1.2.3 control
            这个控制不表达如何控制, 只把用户的控制信息传递给后端

> py.class:
    > m 数据, 类的定义
        m.class.
            实例的初始化(每个对象都是一个类/数组类)
            同结构不同位置的对象, 应该有不同的类名字, 继承自同一个类
        m.init
            init obj
    > v 与数据的初始化有关
        1 最好嵌套
        2   
        3 
    > c 控制
        1 每个对象都有一个独立的名字            +++++++
            所有对象通用类, 初始化自动产生 id
        2 当对象被点击/按下回车之后, 把事件发送给后端
            id + 参数
    
> 怎么产生view 函数?

> 先产生模型
    >> 产生成功
> 拆解 view
    >> 现在去掉一切的封装, 我们直接在
        def v() 里面手写所有的 return (dom)

> 关联 event
    > 把每个可点击、输入 的组件，都必须独立封装，有编号
        > 这需要我们不满足于 def v() 里面的手写内容, 而是需要让组件化的(dom)加入到v里面
        > (dom).id 要进行注册
        > (dom).id 

> compo
    > 所有的compo 都是可以关联event的
    > 如果没有event, 没有必要作为compo
    > 带参数 compo 需要把参数传递给后端, 我们暂时只支持，把compo内部的数据传递出去
    >       那么如何传递compo内部的参数, 就是我们需要的重点

    > compo:
        1 数据 字面传入()
        2 id 自动分配
        3 挂载的行为: 需要在v 里面绑定
        compo.button(
            #id=auto,
            data='self.functor_list',
            event=dict(
                OnClick=root.plan.add_functor(ReadMysql())
            )
        )
            1 这里 onClick 就是 onClick={self.call(self.idx, 'onClick')}
            2 这里的 root.xxx 是执行函数, 用来注册到事件里面
                所有事件应该和module关联

# summery
> 多任务程序 ++++
    我们考虑用户打开多个 plan
    我们必须让所有的节点都能够访问，当前plan(module.root)

    plan = get(plan_name, default_plan_maker())
    set(plan_name, plan)

> id_maker:
    用来给所有的 compo + 类, 注册key
    属于某个plan
    > 每个module = root{
        id_map, 
        data = plan
    }
> event
    1 对于前端发送的回调:
        1 obj.idx > 找到后端 obj
        2 method = method_name
        3 params = dict()
    2 如果注册的回调, 被修改了怎么办？
        (仍然用 idx:)
        约定一个修改规则:
        1 回调访问 确定的对象
            不会被修改
        2 回调访问 不确定的对象(可有可无)
            回调访问子对象
        3 回调修改 而非访问不确定对象
            回调访问确定对象, 由该对象提供标准方法
        4 其他特殊要求，先不实现

> compo:
    用来封装 event+view 的库
    这个产生和编译, compo.js


# 上班时间做什么
因为效率低下，有创造力的工作不在此时做，


> 用新框架实现一个基本页面:
    1 name/f_list/new_f_list/op
        >> 今天搞定/上午搞定

    2 new delete functors
    3 save/load
>
上午已经做通 整个流程
    >> 需要把 key-id 加上
    . 今天
-----------------------------------------------------
我们需要一个 compo 但是compo到底是什么:
1 问题:
    类方法:
        m, v
        我们根据类方法, 产生 m, v
    对象方法:
        产生 idx, clsName
    
    1 我们根据类的声明, 产生 js
    2 v 怎么和compo 关联
        根据 m 的初始化类型, 产生 v
    3 因此, m, v 都是静态变量
        >> 去修改成静态变量

> 增加了compo
    compo 是一个终结符
        任何类调用compo, 而compo, 调用 js.compo 封装的类
        这样我们整个语言就构建出来了
        1 我们的每个类, 都是一个上下文无关语言语法, 描述一个区域里面有多少个子区域
        2 compo类 是一个终结符语法，用来描述某个符号 和真实世界(js/html)的一一对应关系
# xx
..
# xx

# 进度说明
非常牛逼的实现了
a 符号能力
    1 抽象结构是非终结符
        m() 产生通用v
    2 compo(html++)是终结符
        1 compo 定制v
        2 compo 调用的 function, 手动实现

b view 自动产生

# >> 接下来的计划
c compo 下的 event
    js:
        发送信号 => 自动发送信号
        > 传递 call
        > 已经传到后端, 运行良好
    py:
        绑定信号
            <!-- >> 不可验证, 因为数据不能存取 -->
            >> 验证, 当前机制有效
    Auto_type:
        自动类型分析, 用来自动分析 list里存储的 可变类型
        >> 成功
    
## >> 如何存取数据？
save/load
    <!-- 现在的问题是, 数据是每次初始化, 就不可能存储数据 -->
    艰难的完成

# 周二
## 现在需要构建, 数据库, 数据模型
    1 安装mysql, 增加 db_aliyun
        完成
    2 休息一会，然后移植代码
        已经移植了, 现在的问题是:
            怎么开始构建
    >> 已经把之前的算子, 增加到了functor_list 列
    >> 增加了 文本 compo
        >> 这个compo的显示风格不合理, 需要把字符修改一下

这回我们感觉很爽！
现在修改html页面的效率, 已经是以前的n倍了
最快今天到明天可以构建完整的之前的所有设计
----------------------------------------------
> 正在进入mysql-表数据结构的开发
> 已经把 ReadMysql/ColAppend 增加
    >>>>>>>>>
    >> 需要增加一个功能: prev_fields  +++++
        >> functor 调用父节点的方法(传入自己的index)>>
            >> 父节点依次遍历子节点， 调用子节点的 方法: next_fields
                找到index节点, 得到 prev_fields
> save_excel ++++++
    >> 完成
> <input> 改进
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    > placeholder > value
    >>>>>>


.
------------------------------

> 把 code_maker 加入
    >> a 需要把 code_maker 的 参数规范化
        >> 先尝试做通
            >> code generate 和展示 +++
            >> 把code 需要的算子param抽离出来？
                层次化, 组件化完成 ++++++++++++++++
>> 期望今天能够完成所有的！！

    >> b 适当考虑, 算子和 code_maker 一体化
        >> 一定程度 把算子和 plan的其他操作解耦, 把算子独立出来
        > 直接把代码拆开就行, 依赖不深
    
    >> 
.
----------------------------------------------------
# 周三
我们请假一天
把组件搞定, >产生code, 推到git(执行一行命令)

# 周四
在本地同步环境
登陆服务器
调试我们的代码
补充一些简单的内容
>> 我们先不考虑本地同步环境
>> 开始着手写第一个 1v1 表的保存.
    绕过 colAppend
>> 正在准备产生 code
>> 产生成功++++

# 周五我们完成阶段报告
1 明天最重要的事情就是搞定网页版登陆 +++++
然后我们就可以开始调试
    信息加密/解密

这样, 我们把一个搜索功能放在服务器上。
> 搜索功能基本开发完成      +++++++++++++++++++++


>> 完成一个简单例子 1v1
    >>> 一个没有 colAppend 的例子
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        >> 1 通过 db + 关键词, 找到表清单, 然后拿到一个 表结构 +++++++++
        >> 2 要可以新增一个表结构 
            >>(这个以后再自动化)
        >> 3 创建一个真实的自动项目
            > 关联 code_generate()
            >>>>>>>>>>>>>> 失败: 无法访问git
            >> 不要套git, 选择本地脚本代码复制/搬运



>> 一会我们的目标是自动化, 把整个流程做通
    全部流程以非常流畅的方式完成
        >> 下周开始, 我们就会很愉快

2 写文档
3 总结整个项目

.
----------------------------------------










